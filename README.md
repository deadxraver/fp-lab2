# fp-lab2

Выполнил: Чумаченко Даниил

## Требования к разработанному ПО

Мой вариант: pre-set, это префиксное дерево с интерфейсом множества.
В природе префиксное дерево используется для быстрого поиска слов по их началу.

Также структура должна быть моноидом,
должна уметь создаваться из списка или наоборот преобразовываться в него,
релизовать бызовые фпшные функции (отображение, фильтр)...

Протестировать с помощью юнит- и пропертибейзд тестов.

## Ключевые элементы реализации и тесты

### Сама структура

```haskell
data TreeNode = TreeNode Char [TreeNode] | TreeHead [TreeNode] | TreeLeaf deriving (Show)
```

Имеет 3 состояния - голова (не содержит в себе символ, но содержит указатели на дочерние ноды), 
нода (содержит как символ, так и указатели на дочерние),
лист (не содержит ничего и служит неким нуль-терминатором, говорящим, что слово закончилось).

Префиксное дерево -- специфичная структура, ее ноды по отдельности не несут смысловой нагрузки,
смысл вкладывается в формируемую строку от головы до листа.
По этой причине реализовать полиморфность не получилось, так как при иной реализации теряется 
смысл структуры.

Для большего понимания приведу пример.
Есть список строк `["txt", "str", "str1", "str2"]`. 
При представлении в любой другой структуре мы бы каким-нибудь образом расположили 
эти строки в её частях и могли бы поэтому заменить каждую строку на представителя какого-нибудь 
другого типа (например, число или отдельный символ?).
В нашей же структуре это будет выглядеть как-то так:

```
    (  Head  )
    /    |   \
  ('t')('s')( Leaf )
    |    |
  ('x')('t')
    |    |
  ('t')('r')-( Leaf )
    |      \
 ( Leaf )  |\
           | \__('2')-( Leaf )
         ('1')
           |
        ( Leaf )
```

Как видим, для нормального представления нам нужна делимая структура, а именно строка.

Из-за этого некоторые функции получились достаточно примитивные, зато появилась одна новая 
(но об этом позже).

### Реализованное API

Рассмотрим детальнее. Вот так происходит преобразование списка строк в дерево:

```haskell
fromList' :: [String] -> TreeNode -> TreeNode
fromList' list node = foldr insert node list

fromList :: [String] -> TreeNode
fromList list = fromList' list emptyTree
```

А вот так наоборот: 

```haskell
-- current node -- str acc -- results list
toList' :: TreeNode -> String -> [String]
toList' TreeLeaf str = [str]
toList' (TreeNode sym (node : nodeList)) str = toList' node (str ++ [sym]) ++ toList' (TreeNode sym nodeList) str
toList' (TreeNode _ []) _ = []
toList' (TreeHead _) _ = error "TreeHead should not be here"

toList :: TreeNode -> [String]
toList (TreeHead []) = []
toList (TreeHead (node : list)) = filter (/= "") (toList' node "" ++ toList (TreeHead list))
```

И самое интересное, получение всех слов по префиксу:

```haskell
startWith :: String -> TreeNode -> [String]
startWith "" (TreeHead list) = toList $ TreeHead list
startWith "" node = toList' node ""
startWith (c : "") node =
    case findChild c (getChildren node) of
        Nothing -> []
        Just node' -> startWith "" node'
startWith (c : str) node =
    case findChild c (getChildren node) of
        Nothing -> []
        Just node' -> map (c :) (startWith str node')
```

Релизацию остальных функций можно посмотреть [здесь](src/Tree.hs).

### Тестирование

А тесты лежат [здесь](test/). Запуск происходит из [Spec](test/Spec.hs),
unit-тесты находятся в [Unit](test/Unit.hs), 
а property-based в [PropertyBased](test/PropertyBased.hs).

Для последних была использована библиотека QuickCheck, а для юнит -- ...писал сам.

Отчет по тестам находится на гитхабе (зеленая галочка).

### Другое

[Main](app/Main.hs) не несет особой смысловой нагрузки, там приведены примеры и как это выглядит.

Также для контроля качества использовал линтер hlint и форматтер fourmolu.

## Выводы

Итак в ходе реализации я познакомился с префиксным деревом и проперти бейзд тестированием.
Дерево мне понравилось, а к тестированию я остался равнодушен.
Особенно меня порадовала хорошая комбинация множества и префиксного дерева,
так как хранение дубликатов в нем звучит не очень логично.
Также мне было предложено использовать fourmolu вместо ormolu, да, это конечно удобнее
(можно указать директорию с кодом вместо путей к каждому файлу),
но лишние 13 минут к каждому пайплайну ради такого, как мне кажется, не очень оправданы.
В целом на этом всё, всем спасибо за внимание!

